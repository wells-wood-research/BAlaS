<!DOCTYPE html>
<html lang="en">
<head>
    <title>BALS</title>
    <meta charset="UTF-8">
    <script type="text/javascript" 
            src="{{ url_for('static', filename='elm/bals.js') }}">
    </script>
    <script type="text/javascript"
            src="{{ url_for('static', filename='javascript/bio-pv.min.js') }}">
    </script>
    <script type="text/javascript"
            src="{{ url_for('static', filename='javascript/FileSaver.min.js') }}">
    </script>
    <link rel="stylesheet"
          href="{{ url_for('static', filename='css/style.css') }}">
    <link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans+Condensed|Titillium+Web"
          rel="stylesheet">
</head>
<body>
</body>
<div id="main"></div>
<script type="text/javascript">
    var node = document.getElementById('main');
    var storedState = localStorage.getItem('bals');
    var startingState = storedState ? JSON.parse(storedState) : null;
    // This try block will catch a problem with the local storage.
    try {
        var app = Elm.Main.embed(node, startingState);
    }
    catch (e) {
        var app = Elm.Main.embed(node, null);
    }

    app.ports.saveState.subscribe(function(state) {
        localStorage.setItem('bals', JSON.stringify(state));
    });


    // Protein Viewer
    var viewer;
    var prevPicked = null;
    var currentStructure;
    var currentRepresentation;
    var cartoonGeometry; // THIS SHOULD BE DELETED

    // This port initialises the PV viewer, it is trigger on init.
    app.ports.initialiseViewer.subscribe(
        function () {
            var options = {
                width: 'auto',
                height: 'auto',
                antialias: true,
                quality : 'medium'
            };
            const viewerPanel = document.getElementById('viewer');
            viewer = pv.Viewer(viewerPanel, options);
            window.onresize = function(event) {
                viewer.fitParent();
            }
            viewerPanel.addEventListener('mousemove', function(event) {
                var rect = viewer.boundingClientRect();
                var picked = viewer.pick({ x : event.clientX - rect.left,
                                           y : event.clientY - rect.top });
                if (prevPicked !== null && picked !== null &&
                    picked.target() === prevPicked.atom) {
                  return;
                }
                if (prevPicked !== null) {
                  // reset color of previously picked atom.
                  setColorForAtom(prevPicked.node, prevPicked.atom, prevPicked.color);
                }
                if (picked !== null) {
                  var atom = picked.target();
                  app.ports.hoveredName.send(atom.qualifiedName());
                  // get RGBA color and store in the color array, so we know what it was
                  // before changing it to the highlight color.
                  var color = [0,0,0,0];
                  picked.node().getColorForAtom(atom, color);
                  prevPicked = { atom : atom, color : color, node : picked.node() };

                  setColorForAtom(picked.node(), atom, 'red');
                } else {
                  app.ports.hoveredName.send(null);
                  prevPicked = null;
                }
                viewer.requestRedraw();
            });
        }
    );

    function setColorForAtom(go, atom, color) {
        var view = go.structure().createEmptyView();
        view.addAtom(atom);
        go.colorBy(pv.color.uniform(color), view);
    }
    
    // This port handles collecting information from selected files
    // and sending it through to the Elm app.
    app.ports.requestPDBFile.subscribe(function() {
        const fileToLoad = document.getElementById("pdbFileToLoad").files[0];
        const fileReader = new FileReader();
        fileReader.onload = function(fileLoadedEvent) {
            const textFromFileLoaded = fileLoadedEvent.target.result;
            const structure = showStructure(textFromFileLoaded);
            app.ports.receiveStructure.send(structure);
        };
        if (typeof fileToLoad != 'undefined') {
            fileReader.readAsText(fileToLoad, "UTF-8");
        } else {
            app.ports.receiveStructure.send(null);
        }
    });

    app.ports.setVisibility.subscribe(function (selection) {
        const [label, hidden] = selection;
        setVisibility(label, hidden);
    });

    app.ports.colourGeometry.subscribe(function (colourAndLabel) {
        const colour = colourAndLabel[0];
        const label = colourAndLabel[1];
        cartoonGeometry[label].colorBy(pv.color.uniform(colour));
        viewer.requestRedraw();
    });

    app.ports.displayScanResults.subscribe(function (alaScanResults) {
        const structure = displayScanResults(alaScanResults);
        app.ports.receiveStructure.send(structure);
    });

    app.ports.focusOnResidue.subscribe(function (residueResult) {
        focusOnResidue(residueResult);
    });

    // Functions for handling structures.
    function showStructure (pdbString) {
        viewer.clear();
        currentStructure = pv.io.pdb(pdbString);
        viewer.fitTo(currentStructure);
        const chainLabels = currentStructure.chains().map(x => x._L);
        const structure = {
            pdbFile: pdbString,
            chainLabels: chainLabels,
            hidden: chainLabels.map(x => false),
        };
        const chainsSelection = currentStructure
            .chains()
            .map(x => currentStructure.select({chain: x._L}));
        cartoonGeometry = Object();
        for (i = 0; i < chainsSelection.length; i++) { 
            const chain = currentStructure.chains()[i];
            const carGeom = viewer.cartoon(
                chain._L + '_c',
                chainsSelection[i]);
            cartoonGeometry[chain._L] = carGeom;
            viewer.lines(
                chain._L + '_l',
                chainsSelection[i]);
        }
        viewer.addListener('click', function(picked) {
            if (picked === null) return;
            var target = picked.target();
            if (target.qualifiedName !== undefined) {
                var residueInfo = Object();
                residueInfo['chainID'] = target.residue().chain().name();
                residueInfo['aminoAcid'] = target.residue().name();
                residueInfo['residueNumber'] = target.residue().num();
                app.ports.atomClick.send(residueInfo);
            }
        });
        return structure;
    }

    function setVisibility(label, hidden) {
        if (hidden) {
            viewer.hide(label + '_c');
            viewer.hide(label + '_l');
        } else {
            viewer.show(label + '_c');
            viewer.show(label + '_l');
        }
        viewer.requestRedraw();
        return;
    }

    function displayScanResults(alaScanResults) {
        const structure = showStructure(alaScanResults.pdbFile);
        currentStructure.eachResidue(function(residue) {
                residue.setProp('ddG', 0.0);
            });
            for (var i = 0; i < alaScanResults.ligandResults.length; i++) {
                const resResult = alaScanResults.ligandResults[i];
                const res = currentStructure.select(
                    {cname : resResult.chainID,
                     rnum: parseInt(resResult.residueNumber)
                    });
                res.eachResidue(function(residue) {
                    if (resResult.ddG > 0) {
                        residue.setProp('ddG', resResult.ddG);
                    }
                });
            } 
        viewer.clear();
        const receptor = currentStructure.select(
            {cnames : alaScanResults.receptor,
            });
        const ligand = currentStructure.select(
            {cnames : alaScanResults.ligand,
            });
        const nonZeroResLabels = alaScanResults.ligandResults
                .filter(x => (x.ddG !== 0))
                .map(x => x.chainID + x.residueNumber);
        const nonZeroResidues = ligand.residueSelect(function(res) {
            return nonZeroResLabels
                       .includes(res.chain().name() + res.num().toString());
        });
        viewer.cartoon('receptor', receptor,
            { color: pv.color.uniform('#ffffff') });
        viewer.cartoon('ligand', ligand,
                { color: pv.color.byResidueProp(
                    'ddG', pv.color.gradient(['blue', 'red']))});
        viewer.lines('recRes', receptor);
        viewer.ballsAndSticks('ligDDG', ligand);
        return structure;
    }

    function focusOnResidue(residueResult) {
        const residue = currentStructure.select(
            {cname: residueResult.chainID,
             rnum: parseInt(residueResult.residueNumber)
            });
        viewer.fitTo(residue);
    }
</script>
</html>
